Библиотека LCD5110_SSVS

Библиотека LCD дисплея Nokia 5110 для Arduino и chipKit.
Это переделанная библиотека LCD5110_Basic.h версии  2.13	08 Sep 2014

Нововведения:   	1. Добавлен русский шрифт RusFont
2. Не используется пин CS(CE) – его нужно соединить с массой т.е. используются только 4 ноги ардуино.
3. Для функции print() добавлены 2 аргумента – length и filler, которые  работают также как и в функциях printNumI() и printNumF(), а именно дополняют печать спереди символами наполнителями. Например переменная = 5 может отображаться как «05»

Введение:
Вы всегда можете найти самую последнюю версию библиотеки в http://www.RinkyDinkElectronics.com/
 
При использовании функций:  print(), printNumI() и printNumF()
LEFT=0
RIGHT=9999
CENTER=9998

Включенные шрифты
SmallFont и RusFont
 
Размер символов:  6x8 точек 
Количество символов:  14x6=84 шт

MediumNumbers
 
Размер символов:  9x15 точек 
Количество символов:  7x3=21 шт

BigNumbers
 
Размер символов:  10x20 точек 
Количество символов:  6x2=12 шт

Функции:
LCD5110(SCK, MOSI, DC, RST);
Конструктор основной класс
Аргументы: 	SCK: пин для Clock 
MOSI: пин для данных
DC: пин для регистра выбора (данные / команда)
RST: пин для Reset
CS: пин нужно притянуть к земле
Использование: LCD5110 myGLCD(6,7,8,9) ; // Старт экземпляра класса LCD5110

InitLCD([contrast]);
Инициализация LCD...
Аргументы: contrast: <необязательно> лучше его совсем не менять
Значение для контраста (0-127) по умолчанию 70.
Использование: myGLCD.initLCD(); // Инициализация LCD
Примечания: Будет произведен сброс и очистка дисплея

setContrast(contrast); // лучше его совсем не менять
Установка контраста дисплея...
Аргументы: contrast: Значение для контраста (0-127) 
Использование: myGLCD. setContrast(70); // Устанавливает контраст 70

enableSleep();
Перевод  дисплея в спящий режим.
Аргументы: нет
Использование: myGLCD. enableSleep(); // Перевод  дисплея в спящий режим.
Примечания: спящий режим не будет отключать подсветку, так  как это аппаратная функция

disableSleep();
Включение дисплея после спящего режима
Аргументы: нет
Использование: myGLCD. disableSleep(); // Включение дисплея после спящего режима
Примечания: дисплей автоматически очищается, когда режим сна отключается. Выход из сна не будет включать подсветку, так как это аппаратная функция

clrScr();
Очистка экрана
Аргументы: нет
Использование: myGLCD.clrScr(); // Очистка экрана

clrRow(row[, start_x[, end_x]]);
Очистка знакоместа, или всего ряда
Аргументы: 	row: 8 пикселей в высоту строки для очистки(0-5)
start_x: <необязательно> x- координата, начала очистки (по умолчанию = 0)
end_x: <необязательно>  x- координата, конца очистки (по умолчанию = 83)
Использование: myGLCD. clrRow( 5, 42); // Очистка правой половины в  нижней строке

Invert(mode);
Установка инверсии дисплея
Аргументы: mode: 	true – дисплей инвертирован
false – дисплей не инвертирован
Использование: myGLCD. invert( true); // Установка инверсии дисплея

setFont(fontname);
Выбор шрифта для print(), printNumI() или printNumF().
Аргументы: 		fontname: Имя массива, содержащий шрифт, который вы хотите использовать
Использование: 	myGLCD. setFont(RusFont); // Выбираем шрифт под названием RusFont.
Примечания: 		Вы должны объявить массив шрифта в качестве внешнего или включить его в свой скетч.

invertText(mode);
Инвертируется текст, который печатается с print(), printNumI() и printNumF()
Аргументы:	mode: 	true  - Инверсный текст
false – Нормальный текст
Использование:	myOLED.invertText(true); // Инверсный текст
Примечания:		командой SetFont() отключится инверсия

print(st, x, y[, length[, filler]]);
Печатает строку по указанным координатам. Можно использовать равнение LEFT, CENTER и RIGHT, 
как х-координату, чтобы выровнять строку на экране
Аргументы: 		st: строка для печати
x:   x-координата верхнего левого угла первого символа
y:   y- координата верхнего левого угла первого символа
length: <необязательно>  Минимальное количество цифр / символов (включая знак)
filler: <необязательно> символ наполнитель, используемый, чтобы получить минимальную длину. По умолчанию ' ' (пробел).
Использование: 		String vr= String (55)
myGLCD.print(vr,CENTER,0, 3,’0’); // Печать “055”  в центре в верхней части экрана
Примечание: y-координата будет корректироваться, кратно 8 пикселям высоте строки дисплея.
Действительны координаты 0, 8, 16, 24, 32 или 40 
Строка может быть либо массивом символов или объектом string

printNumI(num, x, y[, length[, filler]]);
Печатает целое число в указанных координатах.
Можно использовать равнение LEFT, CENTER и RIGHT, как Х-координата, чтобы выровнять строку на экране
Аргументы:		num: значение для печати (-2,147,483,648 до 2,147,483,647) только int
x:   x-координата верхнего левого угла первого символа
y:   y- координата верхнего левого угла первого символа
length: <необязательно>  Минимальное количество цифр / символов (включая знак),
filler: <необязательно> символ наполнитель, используемый, чтобы получить минимальную длину. Символ будет вставлен перед номером, но после знака....  По умолчанию ' ' (пробел).
Использование: myGLCD. printNumI(num,CENTER,0); // Печатать "Num" в центре в верхней части экрана
Примечание: 	y-координата будет корректироваться, кратно 8 пикселям высоте строки дисплея.
Действительны координаты 0, 8, 16, 24, 32 или 40 

printNumF(num, dec, x, y[, divider[, length[, filler]]]);
Печатает число с плавающей точкой в указанных координатах в буфере экрана
Можно использовать равнение LEFT, CENTER и RIGHT, как Х-координата, чтобы выровнять строку на экране
ВНИМАНИЕ: Числа с плавающей точкой не являются точными, и могут дать странные результаты при сравнении. Используйте по своему усмотрению
Аргументы: 	num: значение для печати 
dec: количество знаков в дробной части (1-5), 0 не поддерживается. Используйте printNumI () вместо этого....
x:   x-координата верхнего левого угла первого символа
y:   y- координата верхнего левого угла первого символа
divider:  < необязательно >
Один символ для использования в качестве десятичной точки. По умолчанию '.' 
length:   < необязательно > Минимальное количество цифр / символов (включая знак) 
filler:   < необязательно >
символ наполнитель, используемый, чтобы получить минимальную длину. Символ будет вставлен перед номером, но после знака.  По умолчанию ' ' (пробел).

Использование: myGLCD.printNumF(num, 3, CENTER,0); // Вывести значение " num " с 3 знаками после запятой по центру в верхней части буфера экрана
Примечания:	Поддерживаемый диапазон зависит от количества дробных цифр
Диапазон прибл. является +/- 2*(10^(9-dec))

Примечание: 	y-координата будет корректироваться, кратно 8 пикселям высоте строки дисплея.
Действительны координаты 0, 8, 16, 24, 32 или 40 


drawBitmap (x, y, data, sx, sy);
Рисует растровое изображения в буфере экрана
Аргументы:		x:     x-координаты верхнего левого угла растрового изображения
y:     y- координаты верхнего левого угла растрового изображения
data:  массив, содержащий растровые данные
sx:    Ширина растрового изображения в пикселях
	sy:    Высота растрового изображения в пикселях
Использование: myGLCD. drawBitmap( 0, 0, bitmap, 32, 32); // Рисует 32x32 пикселей растровое изображение в верхнем левом углу
Примечания:	Вы можете использовать онлайн-инструмент "ImageConverter Mono" для преобразования фотографии в совместимые массивы
Онлайн-инструмент можно найти на веб-сайте Rinky-Dink Electronics.

Требует, чтобы вы #include <avr/pgmspace.h> when using an Arduino other than Arduino Due. While the bitmap data 
при использовании Arduino Arduino кроме Due. В то время как данные растрового

